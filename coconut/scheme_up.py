"""
Coconut threshold credentials scheme, with unconditional privacy.

"""
from bplib.bp import BpGroup, G2Elem
from coconut.utils import *
from coconut.proofs_up import *


def setup(q=1):
    """
    Generate the public parameters.

    Parameters:
        - `q` (integer): the maximum number of attributes that can be embbed in the credentials

    Returns:
        - params: the publc parameters
    """
    coco_ensure(q > 0, "Number of authorities must be positive.")
    G = BpGroup()
    (g1, g2) = G.gen1(), G.gen2()
    hs = [G.hashG1(("h%s" % i).encode("utf8")) for i in range(q)]
    h_blind = G.hashG1(("h_blind").encode("utf8"))
    (e, o) = G.pair, G.order()
    return (G, o, g1, hs, h_blind, g2, e)


def ttp_keygen(params, t, n):
    """
        Generate keys for threshold credentials (executed by a TTP). This protocol can however be executed in a distributed way as illustrated by the following link: https://crysp.uwaterloo.ca/software/DKG/

    Parameters:
        - `params`: public parameters generated by `setup`
        - `t` (integer): the threshold parameter
        - `n` (integer): the total number of authorities

    Returns:
        - `sk` [(Bn, [Bn])]: array containing the secret key of each authority
        - `vk` [(G2Elem, G2Elem, [G2Elem])]: array containing the verification key of each authority
    """
    (G, o, g1, hs, h_blind, g2, e) = params
    q = len(hs)
    coco_ensure(n >= t and t > 0 and q > 0, "Wrong thresholds.")
    # generate polynomials
    v = [o.random() for _ in range(0,t)]
    w = [[o.random() for _ in range(0,t)] for _ in range(q)]
    # generate shares
    x = [poly_eval(v,i) % o for i in range(1,n+1)]
    y = [[poly_eval(wj,i) % o for wj in w] for i in range(1,n+1)]
    # set keys
    sk = list(zip(x, y))
    vk = [(g2, x[i]*g2, [y[i][j]*g2 for j in range(len(y[i]))]) for i in range(len(sk))]
    return (sk, vk)


def keygen(params):
    """
        Generate the secret and verification keys for an authority. This protocol cannot be used for threshold setting.

        Parameters:
        - `params`: public parameters generated by `setup`

        Returns:
        - `sk` (Bn, [Bn]): secret key of the authority
        - `vk` (G2Elem, G2Elem, [G2Elem]): verification key of the authority
    """
    (G, o, g1, hs, h_blind, g2, e) = params
    q = len(hs)
    x = o.random()
    y = [o.random() for _ in range(q)]
    sk = (x, y)
    vk = (g2, x*g2, [yi*g2 for yi in y], [yi*h_blind for yi in y])
    return (sk, vk)


def agg_key(params, vks, threshold=True):
    """
    Aggregate the verification keys.

    Parameters:
        - `params`: public parameters generated by `setup`
        - `vks` [(G2Elem, G2Elem, [G2Elem])]: array containing the verification key of each authority
        - `threshold` (bool): optional, whether to use threshold cryptography or not

    Returns:
        - `aggr_vk`: aggregated verification key
    """
    (G, o, g1, hs, h_blind, g2, e) = params
    # filter missing keys (in the threshold setting)
    filter = [vks[i] for i in range(len(vks)) if vks[i] is not None]
    indexes = [i+1 for i in range(len(vks)) if vks[i] is not None]
    # evaluate all lagrange basis polynomials
    l = lagrange_basis(indexes,o) if threshold else [1 for _ in range(len(vks))]
    # aggregate keys
    (_, alpha, beta, h_blind_yis) = zip(*filter)
    q = len(beta[0])
    aggr_alpha = ec_sum([l[i]*alpha[i] for i in range(len(filter))])
    aggr_beta = [ec_sum([l[i]*beta[i][j] for i in range(len(filter))]) for j in range(q)]
    aggr_h_blind_yis = [ec_sum([l[i]*h_blind_yis[i][j] for i in range(len(filter))]) for j in range(q)]
    aggr_vk = (g2, aggr_alpha, aggr_beta, aggr_h_blind_yis)
    return aggr_vk


def prepare_blind_sign(params, private_m, public_m=[]):
    """
    Build cryptographic material for blind sign.

    Parameters:
        - `params`: public parameters generated by `setup`
        - `private_m` [Bn]: array containing the private attributes
        - `public_m` [Bn]: optional, array containing the public attributes

    Returns:
        - `Ls`: the blinding factors used for issuing
        - `Lambda`: commitments and encryptions to the attributes
    """
    coco_ensure(len(private_m) > 0, "Need some private messages.")
    (G, o, g1, hs, h_blind, g2, e) = params
    attributes = private_m + public_m
    coco_ensure(len(attributes) <= len(hs), "Too many attributes.")
    # build commitment
    r = o.random()
    Ls = [o.random() for m in private_m]
    cm = r*g1 + ec_sum([attributes[i]*hs[i] for i in range(len(attributes))])
    # build Pedersen Commit
    h = G.hashG1(cm.export())
    c = [m*h+L*h_blind for (L, m) in zip(Ls, private_m)]
    # build proofs
    pi_s = make_pi_s_up(params, Ls, c, cm, r, public_m, private_m)
    Lambda = (cm, c, pi_s)
    return (Ls, Lambda)


def blind_sign(params, sk, Lambda, public_m=[]):
    """
    Blindly sign private attributes.

    Parameters:
        - `params`: public parameters generated by `setup`
        - `sk` (Bn, Bn): the secret key of the authority
        - `Lambda`: commitments and encryptions to the attributes
        - `public_m` [Bn]: optional, array containing the public attributes

    Returns:
        - `sigma_tilde`: blinded credential
    """
    (G, o, g1, hs, h_blind, g2, e) = params
    (x, y) = sk
    (cm, c, pi_s) = Lambda
    coco_ensure( (len(c)+len(public_m)) <= len(hs), "Too many attributes.")
    # verify proof of correctness
    coco_ensure(verify_pi_s_up(params, c, cm, pi_s), "User ZKProof failed.")
    # issue signature
    h = G.hashG1(cm.export())
    t1 = [mi*h for mi in public_m]
    t = x*h + ec_sum([yi*ci for yi,ci in zip(y,c+t1)])
    sigma_tilde = (h, t)
    return sigma_tilde


def agg_cred(params, aggr_vk, sigs, Ls, threshold=True):
    """
    Aggregate partial credentials.

    Parameters:
        - `params`: public parameters generated by `setup`
        - `sigs` [(G1Elem, G1Elem)]: array of ordered partial credentials, include `None` if a partial credential is missing (in the threshold setting)
        - `Ls` [Bn]: the blinding factors used for issuing
        - `threshold` (bool): optional, whether to use threshold cryptography or not

    Returns:
        - `aggr_sigma`: aggregated credential
    """
    (G, o, g1, hs, h_blind, g2, e) = params
    (g2, alpha, beta, h_blind_yi) = aggr_vk

    # filter missing credentials (in the threshold setting)
    filter = [sigs[i] for i in range(len(sigs)) if sigs[i] is not None]
    indexes = [i+1 for i in range(len(sigs)) if sigs[i] is not None]
    # evaluate all lagrange basis polynomials
    l = lagrange_basis(indexes,o) if threshold else [1 for _ in range(len(sigs))]
    # aggregate sigature
    (h, s) = zip(*filter)
    aggr_s_raw = ec_sum([l[i]*s[i] for i in range(len(filter))])

    # unblind
    blinder = ec_sum([L*h_blind_yi[i] for i, L in enumerate(Ls)])
    aggr_s = aggr_s_raw - blinder

    aggr_sigma = (h[0], aggr_s)
    return aggr_sigma




def prove_cred(params, aggr_vk, sigma, private_m):
    """
    Build cryptographic material for blind verify.

    Parameters:
        - `params`: public parameters generated by `setup`
        - `aggr_vk`: aggregated verification key
        - `sigma`: credential
        - `private_m` [Bn]: array containing the private attributes

    Returns:
        - `Theta`: randomized credential and cryptographic material to verify them
    """
    assert len(private_m) > 0
    (G, o, g1, hs, g2, e) = params
    (g2, alpha, beta) = aggr_vk
    (h, s) = sigma
    assert len(private_m) <= len(beta)
    r, r_prime = o.random(), o.random()
    (h_prime , s_prime) = (r_prime*h , r_prime*s + r*r_prime*h)
    sigma_prime =(h_prime, s_prime)
    kappa = r*g2 + alpha + ec_sum([private_m[i]*beta[i] for i in range(len(private_m))])
    pi_v = make_pi_v(params, aggr_vk, sigma_prime, private_m, r)
    Theta = (kappa, sigma_prime, pi_v)
    return Theta


def verify_cred(params, aggr_vk, Theta, public_m=[]):
    """
    Verify credentials.

    Parameters:
        - `params`: public parameters generated by `setup`
        - `aggr_vk`: aggregated verification key
        - `Theta`: credential and cryptographic material to verify them
        - `public_m` [Bn]: optional, array containing the public attributes

    Returns:
        - `ret` (bool): whether the credential verifies
    """
    (G, o, g1, hs, g2, e) = params
    (g2, _, beta) = aggr_vk
    (kappa, sigma, pi_v) = Theta
    (h, s) = sigma
    private_m_len = len(pi_v[1])
    coco_ensure(len(public_m)+private_m_len <= len(beta), "Too many parameters")
    # verify proof of correctness
    coco_ensure(verify_pi_v(params, aggr_vk, sigma, kappa, pi_v), "ZK proof failed")
    # add clear text messages
    aggr = G2Elem.inf(G)
    if len(public_m) != 0:
        aggr = ec_sum([public_m[i]*beta[i+private_m_len] for i in range(len(public_m))])
    # verify
    return not h.isinf() and e(h, kappa+aggr) == e(s, g2)


